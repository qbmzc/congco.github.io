---
title: Java并发
date: 2021-4-01
categories:
  - Java
tags:
  - Java
---

![Java并发](https://gitee.com/snowyan/image/raw/master/md/wallhaven-763ml3.jpg)

<!-- more -->

## 线程

### 三种方法

1. 实现Runnable接口;
2. 实现Callable接口；
3. 继承Thread类。

实现Runnable和Callable接口的类只能当做是一个可以在线程中运行的任务，不是真正意义上的线程，还是需要Thread类来调用，执行run()方法是作为一个普通的方法执行，而不是启动线程执行，start()方法是线程就绪，获得cpu时间片就可以执行run()方法。

与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。

实现接口会更好一些，因为：

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

### 线程状态

| 状态                    | 说明                                 |
| ----------------------- | ------------------------------------ |
| NEW（新建）             | 创建后未启动，没有调用start()方法    |
| RUNNABLE(运行)          | 可以被运行，具体看操作系统的资源调度 |
| BLOCKED(阻塞)           | 表示线程阻塞于锁                     |
| WAITING（等待）         | 等待其他线程显式唤醒                 |
| TIMED_WAITING(超时等待) | 时间到了之后自动被系统唤醒           |
| TERMINATED（终止）      | 任务结束之后结束或出现异常而结束     |
|                         |                                      |

![](https://gitee.com/snowyan/image/raw/master/md/image-20210401160446551.png)

## 锁

### synchronized

底层是有两个指令`monitorenter`和`monitorexit`来实现同步的，JDK1.6之前，`monitor`的实现依赖于操作系统底层`Mutex Lock`互斥锁。

操作系统实现线程之间的切换需要从用户态切换到内核态/核心态，这个成本非常高，状态之间的转换是消耗资源的，需要相对比较长的时间，所以此时的同步操作是一个重量级的操作，性能很低。

`JDK1.6`带来了新变化，有三种实现方式，偏向锁，轻量级锁（自旋锁）和重量级锁，由偏向到轻量级再到重量级，就是锁升级

1. 对于普通同步方法，锁是当前实例对象。

2. 对于静态同步方法，锁是当前类的Class对象。

3. 对于同步方法块，锁是`synchronized`括号里配置的对象。

- 同步代码块 synchronized (this)

```java
public void func() {
    synchronized (this) {
        // 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。
    }
}

```



- 同步方法 

  ```java
  public synchronized void func () {
      // ...
  }
  ```

- 同步一个类

```java
public void func() {
    synchronized (SynchronizedExample.class) {
        // 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。
    }
}
```

- 同步一个静态方法

```java
public synchronized static void fun() {
    // ...作用于整个类。
}
```

### ReentrantLock

ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁

### 比较

**1. 锁的实现**

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

synchronized不需要手动释放锁，ReentrantLock需要手动释放。

**2. 性能**

新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。

**3. 等待可中断**

当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。

ReentrantLock 可中断，而 synchronized 不行。

**4. 公平锁**

公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

**5. 锁绑定多个条件**

一个 ReentrantLock 可以同时绑定多个 Condition 对象。

### 使用选择

除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM  实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized  不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。

## 死锁

线程t1和线程t2互相等待对方释放锁。

### 避免死锁

- 避免一个线程同时获取多个锁。

- 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。

- 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。

## J.U.C

### AQS

### CountDownLatch

用来控制一个或者多个线程等待多个线程。

维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。

```java
package com.cong.juc;
import com.cong.juc.enums.CountryEnum;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;

/**
 * CountDownLatch示例
 *
 * @author cong
 * <p>
 * created on 2021/3/31 上午10:00
 */
public class CountDownLatchDemo {
    /**
     * 都over以后才可以离开
     *
     * @param args
     */
    public static void main(String[] args) {
        try {
            CountDownLatch latch = new CountDownLatch(6);
            for (int i = 1; i <= 6; i++) {
                new Thread(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 国，被灭");
                    latch.countDown();
                }, Objects.requireNonNull(CountryEnum.forEachCountryEnum(i)).getName()).start();
            }
            latch.await();
            System.out.println(Thread.currentThread().getName() + "\t 秦完成统一");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



```java
package com.cong.juc.enums;
/**
 * @author cong
 * <p>
 * created on 2021/3/31 上午10:11
 */

public enum CountryEnum {
    QI(1, "齐"),
    CU(2, "楚"), YAN(3, "燕"), HAN(4, "韩"), ZHAO(5, "赵"), WEI(6, "魏"), QIN(7, "秦");
    private Integer retCode;
    private String name;

    CountryEnum(Integer retCode, String name) {
        this.retCode = retCode;
        this.name = name;
    }

    public static CountryEnum forEachCountryEnum(int key){
        CountryEnum[] countryEnums = CountryEnum.values();
        for (CountryEnum countryEnum : countryEnums) {
            if (key==countryEnum.getRetCode())
                return countryEnum;
        }
        return null;
    }

    public Integer getRetCode() {
        return retCode;
    }

    public void setRetCode(Integer retCode) {
        this.retCode = retCode;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

结果

```bash
楚	 国，被灭
韩	 国，被灭
齐	 国，被灭
燕	 国，被灭
赵	 国，被灭
魏	 国，被灭
main	 秦完成统一
```

###  CyclicBarrier 

用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。

和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。

CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。

CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。

```java
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties <= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}

public CyclicBarrier(int parties) {
    this(parties, null);
}
```



```java
package com.cong.juc;

import java.util.concurrent.CyclicBarrier;

/**
 * @author cong
 * <p>
 * created on 2021/3/31 上午10:31
 */
public class CycllicBarrierDemo {

    public static void main(String[] args) {
        //第二种构造函数
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> System.out.println("over"));
        for (int i = 1; i <= 7; i++) {
            new Thread(()->{
                System.out.println(Thread.currentThread().getName()+"\t 已完成");
                try {
                    //先到的被阻塞，完成之后再继续
                    cyclicBarrier.await();
                }catch (Exception e){
                    e.printStackTrace();
                }
            },String.valueOf(i)).start();
        }
    }
}
```



```bash
1	 已完成
3	 已完成
2	 已完成
4	 已完成
5	 已完成
6	 已完成
7	 已完成
over
```



### Semaphore

Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

```java
package com.cong.juc;

import com.sun.javaws.Main;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * 信号量 多资源《===》多个线程
 * @author cong
 * <p>
 * created on 2021/3/31 上午10:38
 */
public class SemaphoreDemo {

    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i < 8; i++) {
            new Thread(()->{
                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName()+"\t 获得资源");
                    try {
                        TimeUnit.SECONDS.sleep(3);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()+"等待三秒钟离开");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    semaphore.release();
                }
            },String.valueOf(i)).start();
        }

    }
}
```



```bash
## 顺序不一定
1	 获得资源
3	 获得资源
2	 获得资源
2等待三秒钟离开
1等待三秒钟离开
3等待三秒钟离开
5	 获得资源
4	 获得资源
6	 获得资源
5等待三秒钟离开
4等待三秒钟离开
6等待三秒钟离开
7	 获得资源
7等待三秒钟离开
```

## 线程池

![image-20210401171335184](/home/cong/.config/Typora/typora-user-images/image-20210401171335184.png)

### 拒绝策略

- AbortPolicy：直接抛出异常。

- CallerRunsPolicy：只用调用者所在线程来运行任务。

- DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。

- DiscardPolicy：不处理，丢弃掉。

当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录

日志或持久化存储不能处理的任务。



## ThreadLocal

- 为每一个线程创建一个副本
- 实现线程的上下文传递对象

如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用get和set方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

### 原理

```java
publicclassThreadimplementsRunnable { ......
    //与此线程有关的ThreadLocal值。由ThreadLocal类维
    ThreadLocal.ThreadLocalMapthreadLocals=null;
    //与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护
    ThreadLocal.ThreadLocalMapinheritableThreadLocals=null; 
  }
```

ThreadLocal内部维护的是一个类似Map的ThreadLocalMap数据结构，key为当前对象的Thread对象，值为 Object 对象。

比如我们在同一个线程中声明了两个ThreadLocal对象的话，会使用Thread内部都是使用仅有那个ThreadLocalMap存放数据的，ThreadLocalMap的 key 就是ThreadLocal对象，value 就是ThreadLocal对象调用set方法设置的值。

###  ThreadLocal 内存泄露问题

ThreadLocalMap中使用的 key 为ThreadLocal的弱引用,而 value 是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用set()、get()、remove()方法的时候，会清理掉 key 为 null的记录。使用完ThreadLocal方法后最好手动调用remove()方法

**线程池的使用也会导致内存泄露问题**

## CAS

VM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止.

三大问题

- ABA问题,AtomicStampedReference来解决ABA

```java
public boolean compareAndSet(
V expectedReference, // 预期引用
V newReference, // 更新后的引用
int expectedStamp, // 预期标志
int newStamp // 更新后的标志
)
```



- 循环时间长开销大
- 只能保证一个共享变量的原子操作。





## 良好实践



