---
title: GC垃圾收集器
date: 2019-08-10
tags:
  - GC
  - JVM
categories:
  - Java
---

## 概述

简单来说，垃圾收集由两步构成：查找不再使用的对象，以及释放这些对象所管理的内存。

## 分代垃圾收集器

根据情况将堆划分成不同的代（Generation）。这些代被称为“老年代”（Old Generation 或 Tenured Generation）和“新生代”（Young Generation）。新生代又被进一步地划分为不同的区段，分别称为 Eden 空间和 Survivor 空间（不过 Eden 有时会被错误地用于指代整个新生代）。

采用分代机制的原因是很多对象的生存时间非常短。  

Java 中，这种操作是非常普遍的，所以垃圾收集器设计时就特别考虑要处理大量（有时候是大多数）的临时对象。这也是分代设计的初衷之一。新生代是堆的一部分，对象首先在新生代中分配。新生代填满时，垃圾收集器会暂停所有的应用线程，回收新生代空间。不再使用的对象会被回收，仍然在使用的对象会被移动到其他地方。这种操作被称为 Minor GC。

采用这种设计有两个性能上的优势。其一，由于新生代仅是堆的一部分，与处理整个堆相比，处理新生代的速度更快。而这意味着应用线程停顿的时间会更短。你可能也看到了这其中的权衡，这意味着应用程序线程会更频繁地发生停顿，因为 JVM 不再等到整个堆都填满才进行垃圾收集；本章后续部分会针对其利弊进行深入的讨论。然而，就目前而言，更短的停顿显然能带来更多的优势，即使发生的频率更高。

第二个优势源于新生代中对象分配的方式。对象分配于 Eden 空间（占据了新生代空间的绝大多数）。垃圾收集时，新生代空间被清空，Eden 空间中的对象要么被移走，要么被回收；所有的存活对象要么被移动到另一个 Survivor 空间，要么被移动到老年代。由于所有的对象都被移走，相当于新生代空间在垃圾收集时自动地进行了一次压缩整理。

所有的垃圾收集算法在对新生代进行垃圾回收时都存在“时空停顿(stop-the-world)”现象。

对象不断地被移动到老年代，最终老年代也会被填满，JVM 需要找出老年代中不再使用的对象，并对它们进行回收。而这便是垃圾收集算法差异最大的地方。简单的垃圾收集算法直接停掉所有的应用线程，找出不再使用的对象，对其进行回收，接着对堆空间进行整理。这个过程被称为 Full GC，通常导致应用程序线程长时间的停顿。

## 垃圾收集分类

- 部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集器，其中又分为：

  1. 新生代收集（ Minor GC/Young GC）:指目标只是新生代的垃圾收集。
  2. 老年代收集（Manjor GC/Old GC）:指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法在不同的资料上常又不同所指。
  3. 混合收集（Mixed GC）:指目标是收集整个新生代及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。

- 整堆收集（Full GC）:收集整个Java堆和方法区的垃圾收集。

## 收集算法

- 标记-清除：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可也反过来。
- 标记-复制：按比例划分内存，每次使用其中一块，用完之后，将还存活的对象复制到另外一块上，清理已使用的那一块。
- 标记-整理：老年代一般不能使用标记-复制，让所有存活的对象都向内存空间一端移动，然后直接清理掉边界的内存。
## GC收集器

JVM 提供了以下几种不同的垃圾收集器。

### Serial垃圾收集器

Serial 垃圾收集器是四种垃圾收集器中最简单的一种。如果应用运行在 Client 型虚拟机（Windows 平台上的 32 位 JVM 或者是运行在单处理器机器上的 JVM）上，这也是默认的垃圾收集器。

Serial 收集器使用单线程清理堆的内容。使用 Serial 收集器，无论是进行 Minor GC 还是 Full GC，清理堆空间时，所有的应用线程都会被暂停。进行 Full GC 时，它还会对老年代空间的对象进行压缩整理。通过 `-XX:+UseSerialGC` 标志可以启用 Serial 收集器（大多数情况下，如果可以使用这个标志，默认就会开启）。注意，跟大多数的 JVM 标志不同，关闭 Serial 收集器不能简单地将加号符变成减号符（譬如，使用 `-XX:-UseSerialGC`）。在 Serial 收集器作为默认收集器的系统上，如果需要关闭 Serial 收集器，可以通过指定另一种垃圾收集器来实现。

### Throughput/PS&PO垃圾收集器**

Throughput 收集器是 Server 级虚拟机（多 CPU 的 Unix 机器以及任何 64 位虚拟机）的默认收集器。

Throughput 收集器使用多线程回收新生代空间，Minor GC 的速度比使用 Serial 收集器快得多。处理老年代时 Throughput 收集器也能使用多线程方式。这已经是 JDK 7u4 及之后的版本的默认行为，对于之前老版本的 JDK 7 虚拟机，通过 `-XX:+UseParallelOldGC` 标志可以开启这个功能。由于 Throughput 收集器使用多线程，Throughput 收集器也常常被称为 Parallel 收集器。Throughput 收集器在 Minor GC 和 Full GC 时会暂停所有的应用线程，同时在 Full GC 过程中会对老年代空间进行压缩整理。由于在大多数适用的场景，它已经是默认的收集器，所以你基本上不需要显式地启用它。如果需要，可以使用 `-XX:+UseParallelGC`、`-XX:+UseParallelOldGC` 标志启用 Throughput 收集器。

### CMS收集器

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

CMS 收集器设计的初衷是为了消除 Throughput 收集器和 Serial 收集器 Full GC 周期中的长时间停顿。CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。然而，这其中最显著的不同是，CMS 不再使用 Throughput 的收集算法（`-XX:+UseParallelGC`），改用新的算法来收集新生代对象（使用 `-XX:+UseParNewGC` 标志）。

CMS 收集器在 Full GC 时不再暂停应用线程，而是使用若干个后台线程定期地对老年代空间进行扫描，及时回收其中不再使用的对象。这种算法帮助 CMS 成为一个低延迟的收集器：应用线程只在 Minor GC 以及后台线程扫描老年代时发生极其短暂的停顿。应用程序线程停顿的总时长与使用 Throughput 收集器比起来短得多。

这里额外付出的代价是更高的 CPU 使用：必须有足够的 CPU 资源用于运行后台的垃圾收集线程，在应用程序线程运行的同时扫描堆的使用情况。除此之外，后台线程不再进行任何压缩整理的工作，这意味着堆会逐渐变得碎片化。如果 CMS 的后台线程无法获得完成他们任务所需的 CPU 资源，或者如果堆变得过度碎片化以至于无法找到连续空间分配对象，CMS 就蜕化到 Serial 收集器的行为：暂停所有应用线程，使用单线程回收、整理老年代空间。这之后又恢复到并发运行，再次启动后台线程（直到下一次堆变得过度碎片化）。通过 `-XX:+UseConcMarkSweepGC`、`-XX:+UseParNewGC` 标志（默认情况下，这两个标志都是禁用的）可以启用 CMS 垃圾收集器。

CMS是一款基于“标记—清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的，JDK9废弃），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction(JDK9废弃)，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。

ParNew使之上是Serial收集器的多线程并行版本，只有它能够与CMS收集器配合工作.

#### CMS不能和ParallelScavenge配合工作的原因

1. 一个面向低延迟，一个面向高吞吐量，目标不一致
2. 技术上的原因是PS收集器及G1收集器等都没有使用Hotspot中原本设计的垃圾收集器的分带框架，而选择另外独立实现。Serial、ParNew则共用了这部分代码。

### G1垃圾收集器

G1 垃圾收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于 4 GB）时产生的停顿。G1 收集算法将堆划分为若干个区域（Region），不过它依旧属于分代收集器。这些区域中的一部分包含新生代，新生代的垃圾收集仍然采用暂停所有应用线程的方式，将存活对象移动到老年代或者 Survivor 空间。同其他的收集算法一样，这些操作也利用多线程的方式完成。

G1 收集器属于 Concurrent 收集器：老年代的垃圾收集工作由后台线程完成，大多数的工作不需要暂停应用线程。由于老年代被划分到不同的区域，G1 收集器通过将对象从一个区域复制到另一个区域，完成对象的清理工作，这也意味着在正常的处理过程中，G1 收集器实现了堆的压缩整理（至少是部分的整理）。因此，使用 G1 收集器的堆不大容易发生碎片化——虽然这种问题无法避免。

同 CMS 收集器一样，避免 Full GC 的代价是消耗额外的 CPU 周期：负责垃圾收集的多个后台线程必须能在应用线程运行的同时获得足够的 CPU 运行周期。通过标志 `-XX:+UseG1GC`（默认值是关闭的）可以启动 G1 垃圾收集器。


> 相关书籍：  
Title               : Java性能权威指南  
Author(s)           : [美] 奥克斯（Oaks,S.）
Publisher           : 人民邮电出版社  
深入理解Java虚拟机(第3版)
